<!DOCTYPE html>
<html>
  <head>
    <title>Branching</title>
    <style>html,body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        }
     </style>
   </head>
  <body>
    <canvas id="canvas">
    </canvas>
<script>
let canvas = document.getElementById('canvas');
let ctx = canvas.getContext("2d");
canvas.height = window.innerHeight;
canvas.width = window.innerWidth;

function update() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
};

class JunctionWest {
    constructor(length, width) {
        this.grid = Array.from({
            length: length
        }, () => (Array.from({
            length: width
        }, () => ('fill'))));
    };
    branch(x, y, shifts) {
        let picks = [];
        let options = [];
        let offset = 0;
        for (let count = x; count < this.grid[x].length; count++) {
            picks.push(count);
        };
        for (let count = 0; count < shifts; count++) {
            let o = Math.floor(Math.random() * picks.length);
            let choice = picks[o];
            picks.splice(o, 1);
            options.push([choice, Math.random() < 0.5 ? 1 : -1]);
        };

        for (let count = x; count < this.grid[x].length; count++) {
            let flag = [0, 1];
            for (let c = 0; c < options.length; c++) {
                if (options[c][0] === count) {
                    offset = offset + options[c][1];
                    flag = [1, options[c][1]];
                }
            };
            let k = y + offset;
            if (k < 0) {
                k = 0
            };
            if (k > this.grid.length - 1) {
                k = this.grid.length - 1
            }
            this.grid[count][k] = 'hole';
            if (flag[0]) {
                this.grid[count][k - flag[1]] = 'hole';
            }
        }
    }
};

let jw = new JunctionWest(100, 100);

requestAnimationFrame(function draw() {
    if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
        update();
    };
    ctx.fillStyle = '#FFFFFF';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    let gridX = window.innerWidth / jw.grid.length;
    let gridY = window.innerHeight / jw.grid[0].length;
    ctx.fillStyle = '#000000'
    for (let count in jw.grid) {
        for (let coun in jw.grid[count]) {
            if (jw.grid[count][coun] === 'fill') {
                ctx.fillRect((window.innerWidth / jw.grid.length) * count, (window.innerHeight / jw.grid[0].length) * coun, gridX, gridY)
            }
        }
    }
    requestAnimationFrame(draw);
});
</script>
  </body>
</html>
